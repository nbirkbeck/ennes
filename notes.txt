Palettes:
-Image and sprite, each have 16 colors. They index colors in a global pallette.

Pattern tables:
-2 of them (screen pattern table, and sprite). They are both just 1-bit index. 
-Pattern table shift (12)
-This implies that the memory of the two pattern tables is 4096 bytes

Rendering:
-The 0-th color in the image palette is the background color.

There are 3 layers (0, 1, 2), each of size 272.

Drawing a byte:
-Loads in 2 bytes, the color is made of two bytes (A B).
-Each pixel is 4 bits:
  -2 bits (little end first) from both A and B
  -Upper 2 bits comes from a predefined few bits
    -Read from attribute in a sprite.
  -This is or'ed with the palette (maybe that is even higher order bits)
-Color only drawn if lower 2 bits are non-zero.
-Layer1 seems to just be a count (only set when on sprite 0)?

Sprite memory layout:
 uint8 y_minus_1;
 uint8 pattern;
 uint8 att; // upper_color:2, below_background:bit5
 uint8 x;

Pattern index gets adjusted:
 [extra adjustments for 8x16 sprite mode] 
 +1 if offsety >=8

What is 8x16 size sprite?
-Seems to be a mode where _all_ sprites are 8x16?

Name table:
-1024 bytes each
-Contains an index into selected pattern table.
-There is also an attribute table. Controls upper 2 bits of color. Looks like it is packed at end of name-table.

Quirks:
-Sprites only when control2 bit 4 is set.
-Render only when control2 bit 3 is set.


Ultimately, what you care about is for each pixel, which pattern table
it came from (and maybe some flags used to draw it), whether it was a sprite
that drew it, or whether it was the name table.

Not clear whether any of the other state is really necessary.

-We have a background color
-The background layer.
-For each connected sprite that has similar colors (and is continous), we want to extract
